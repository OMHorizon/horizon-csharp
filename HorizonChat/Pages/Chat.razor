@page "/chat"
@using HorizonChat.Services
@using System.Net.WebSockets
@using System.Text
@inject UserService UserService
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<PageTitle>Chat - HorizonChat</PageTitle>

<div class="chat-container">
    <div class="chat-header">
        <h2>HorizonChat</h2>
        <div class="user-info">
            <span class="username-badge">@UserService.Username</span>
        </div>
    </div>

    <div class="chat-messages" @ref="messagesContainer">
        @foreach (var message in messages)
        {
            <div class="message @(message.IsOwnMessage ? "own-message" : "other-message")">
                <div class="message-header">
                    <span class="message-username">@message.Username</span>
                    <span class="message-time">@message.Timestamp.ToString("HH:mm")</span>
                </div>
                <div class="message-content">@message.Content</div>
            </div>
        }
        @if (messages.Count == 0)
        {
            <div class="no-messages">
                <p>No messages yet. Start the conversation! üí¨</p>
            </div>
        }
    </div>

    <div class="chat-input-container">
        <input 
            type="text" 
            class="form-control chat-input" 
            @bind="currentMessage" 
            @bind:event="oninput"
            @onkeypress="HandleKeyPress"
            placeholder="Type a message..."
            disabled="@(!isConnected)" />
        <button 
            class="btn btn-primary send-btn" 
            @onclick="SendMessage"
            disabled="@(!isConnected || string.IsNullOrWhiteSpace(currentMessage))">
            Send
        </button>
    </div>

    <div class="connection-status @(isConnected ? "connected" : "disconnected")">
        @(isConnected ? "‚óè Connected" : "‚óã Disconnected")
    </div>
</div>

@code {
    private ElementReference messagesContainer;
    private ClientWebSocket? webSocket;
    private List<ChatMessage> messages = new();
    private string currentMessage = string.Empty;
    private bool isConnected = false;
    private CancellationTokenSource? cancellationTokenSource;

    protected override async Task OnInitializedAsync()
    {
        // Redirect to welcome if no username
        if (!UserService.HasUsername)
        {
            NavigationManager.NavigateTo("/welcome");
            return;
        }

        await ConnectToWebSocket();
    }

    private async Task ConnectToWebSocket()
    {
        try
        {
            webSocket = new ClientWebSocket();
            cancellationTokenSource = new CancellationTokenSource();
            
            var uri = new Uri($"ws://localhost:5000/ws");
            await webSocket.ConnectAsync(uri, cancellationTokenSource.Token);
            isConnected = true;
            StateHasChanged();

            // Start receiving messages
            _ = ReceiveMessages();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"WebSocket connection error: {ex.Message}");
            isConnected = false;
        }
    }

    private async Task ReceiveMessages()
    {
        var buffer = new byte[1024 * 4];
        
        try
        {
            while (webSocket?.State == WebSocketState.Open && cancellationTokenSource?.Token.IsCancellationRequested == false)
            {
                var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), cancellationTokenSource.Token);
                
                if (result.MessageType == WebSocketMessageType.Text)
                {
                    var messageText = Encoding.UTF8.GetString(buffer, 0, result.Count);
                    
                    // Parse message format: "username: message"
                    var parts = messageText.Split(new[] { ": " }, 2, StringSplitOptions.None);
                    var username = parts.Length > 1 ? parts[0] : "Unknown";
                    var content = parts.Length > 1 ? parts[1] : messageText;
                    
                    messages.Add(new ChatMessage
                    {
                        Username = username,
                        Content = content,
                        Timestamp = DateTime.Now,
                        IsOwnMessage = username == UserService.Username
                    });
                    
                    await InvokeAsync(StateHasChanged);
                    await ScrollToBottom();
                }
                else if (result.MessageType == WebSocketMessageType.Close)
                {
                    await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, string.Empty, CancellationToken.None);
                    isConnected = false;
                    await InvokeAsync(StateHasChanged);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error receiving message: {ex.Message}");
            isConnected = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(currentMessage) || webSocket?.State != WebSocketState.Open)
            return;

        try
        {
            // Format: "username: message"
            var messageToSend = $"{UserService.Username}: {currentMessage.Trim()}";
            var bytes = Encoding.UTF8.GetBytes(messageToSend);
            await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
            
            currentMessage = string.Empty;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error sending message: {ex.Message}");
        }
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(currentMessage))
        {
            await SendMessage();
        }
    }

    private async Task ScrollToBottom()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", 
                "document.querySelector('.chat-messages').scrollTop = document.querySelector('.chat-messages').scrollHeight");
        }
        catch { }
    }

    public async ValueTask DisposeAsync()
    {
        cancellationTokenSource?.Cancel();
        
        if (webSocket?.State == WebSocketState.Open)
        {
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
        }
        
        webSocket?.Dispose();
        cancellationTokenSource?.Dispose();
    }

    private class ChatMessage
    {
        public string Username { get; set; } = string.Empty;
        public string Content { get; set; } = string.Empty;
        public DateTime Timestamp { get; set; }
        public bool IsOwnMessage { get; set; }
    }
}
