@page "/chat"
@using HorizonChat.Services
@using System.Net.WebSockets
@using System.Text
@inject UserService UserService
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inject ILogger<Chat> Logger
@inject IConfiguration Configuration
@implements IAsyncDisposable

<PageTitle>Chat - App CFL</PageTitle>

<div class="chat-container">
    <div class="chat-header">
        <h2>App CFL</h2>
        <div class="user-info">
            <span class="username-badge">@UserService.Username</span>
        </div>
    </div>

    <div class="chat-messages" @ref="messagesContainer">
        @foreach (var message in messages)
        {
            <div class="message @(message.IsOwnMessage ? "own-message" : "other-message")">
                <div class="message-header">
                    <span class="message-username">@message.Username</span>
                    <span class="message-time">@message.Timestamp.ToString("HH:mm")</span>
                </div>
                <div class="message-content">@message.Content</div>
            </div>
        }
        @if (messages.Count == 0)
        {
            <div class="no-messages">
                <p>No messages yet. Start the conversation! üí¨</p>
            </div>
        }
    </div>

    <div class="chat-input-container">
        <input 
            type="text" 
            class="form-control chat-input" 
            @bind="currentMessage" 
            @bind:event="oninput"
            @onkeypress="HandleKeyPress"
            placeholder="Type a message..."
            disabled="@(!isConnected)" />
        <button 
            class="btn btn-primary send-btn" 
            @onclick="SendMessage"
            disabled="@(!isConnected || string.IsNullOrWhiteSpace(currentMessage))">
            Send
        </button>
    </div>

    <div class="connection-status @(isConnected ? "connected" : "disconnected")">
        @(isConnected ? "‚óè Connected" : "‚óã Disconnected")
    </div>
</div>

@code {
    private const int BufferSize = 1024 * 4;
    private const string MessageDelimiter = ": ";
    
    private ElementReference messagesContainer;
    private ClientWebSocket? webSocket;
    private readonly List<ChatMessage> messages = new();
    private string currentMessage = string.Empty;
    private bool isConnected;
    private CancellationTokenSource? cancellationTokenSource;

    protected override async Task OnInitializedAsync()
    {
        // Redirect to welcome if no username
        if (!UserService.HasUsername)
        {
            NavigationManager.NavigateTo("/welcome");
            return;
        }

        await ConnectToWebSocketAsync();
    }

    private async Task ConnectToWebSocketAsync()
    {
        try
        {
            webSocket = new ClientWebSocket();
            cancellationTokenSource = new CancellationTokenSource();
            
            // Use configuration instead of hardcoded URL
            var wsUrl = Configuration["WebSocketUrl"] ?? "ws://localhost:5000/ws";
            var uri = new Uri(wsUrl);
            
            await webSocket.ConnectAsync(uri, cancellationTokenSource.Token);
            isConnected = true;
            StateHasChanged();

            // Start receiving messages - properly handle async operation
            _ = Task.Run(async () => await ReceiveMessagesAsync(), cancellationTokenSource.Token);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "WebSocket connection error");
            isConnected = false;
        }
    }

    private async Task ReceiveMessagesAsync()
    {
        var buffer = new byte[BufferSize];
        
        try
        {
            while (webSocket?.State == WebSocketState.Open && 
                   cancellationTokenSource is { IsCancellationRequested: false })
            {
                var result = await webSocket.ReceiveAsync(
                    new ArraySegment<byte>(buffer), 
                    cancellationTokenSource.Token);
                
                if (result.MessageType == WebSocketMessageType.Text)
                {
                    var messageText = Encoding.UTF8.GetString(buffer, 0, result.Count);
                    ProcessReceivedMessage(messageText);
                    
                    await InvokeAsync(StateHasChanged);
                    await ScrollToBottomAsync();
                }
                else if (result.MessageType == WebSocketMessageType.Close)
                {
                    await CloseWebSocketAsync(WebSocketCloseStatus.NormalClosure, "Server closed connection");
                    isConnected = false;
                    await InvokeAsync(StateHasChanged);
                }
            }
        }
        catch (OperationCanceledException)
        {
            Logger.LogInformation("WebSocket receive operation was cancelled");
        }
        catch (WebSocketException ex)
        {
            Logger.LogError(ex, "Error receiving WebSocket message");
            isConnected = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void ProcessReceivedMessage(string messageText)
    {
        // Parse message format: "username: message"
        var parts = messageText.Split(MessageDelimiter, 2, StringSplitOptions.None);
        var username = parts.Length > 1 ? parts[0] : "Unknown";
        var content = parts.Length > 1 ? parts[1] : messageText;
        
        messages.Add(new ChatMessage
        {
            Username = username,
            Content = content,
            Timestamp = DateTime.Now,
            IsOwnMessage = username == UserService.Username
        });
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(currentMessage) || webSocket?.State != WebSocketState.Open)
            return;

        try
        {
            var messageToSend = $"{UserService.Username}{MessageDelimiter}{currentMessage.Trim()}";
            var bytes = Encoding.UTF8.GetBytes(messageToSend);
            await webSocket.SendAsync(
                new ArraySegment<byte>(bytes), 
                WebSocketMessageType.Text, 
                endOfMessage: true, 
                CancellationToken.None);
            
            currentMessage = string.Empty;
        }
        catch (WebSocketException ex)
        {
            Logger.LogError(ex, "Error sending message");
            isConnected = false;
            StateHasChanged();
        }
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(currentMessage))
        {
            await SendMessage();
        }
    }

    private async Task ScrollToBottomAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync(
                "eval", 
                "document.querySelector('.chat-messages').scrollTop = document.querySelector('.chat-messages').scrollHeight");
        }
        catch (JSException ex)
        {
            Logger.LogWarning(ex, "Failed to scroll to bottom");
        }
    }

    private async Task CloseWebSocketAsync(WebSocketCloseStatus closeStatus, string statusDescription)
    {
        if (webSocket?.State == WebSocketState.Open)
        {
            try
            {
                await webSocket.CloseAsync(closeStatus, statusDescription, CancellationToken.None);
            }
            catch (WebSocketException ex)
            {
                Logger.LogWarning(ex, "Error closing WebSocket");
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (cancellationTokenSource is not null)
        {
            cancellationTokenSource.Cancel();
            cancellationTokenSource.Dispose();
        }
        
        if (webSocket is not null)
        {
            await CloseWebSocketAsync(WebSocketCloseStatus.NormalClosure, "Component disposing");
            webSocket.Dispose();
        }

        GC.SuppressFinalize(this);
    }

    private sealed class ChatMessage
    {
        public required string Username { get; init; }
        public required string Content { get; init; }
        public DateTime Timestamp { get; init; }
        public bool IsOwnMessage { get; init; }
    }
}
